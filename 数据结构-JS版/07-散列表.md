## 一 散列介绍
#### 1.1 散列表
散列是非常常用的数据存储技术，散列后的数据可以快速的插入或者取用，散列使用的数据结构叫做散列表。但是相应的，查找的效率变得很低，比如找出数据中的最大和最小值。
本节案例的散列表根据数组开发，所有元素根据和该元素对应的健，保存在数组的特定位置。使用散列表存储数据时，通过一个散列函数将健映射为一个数字，这个数字的范围是0到散列表的长度。
#### 1.2 碰撞
理想情况下，散列函数会将每个健值映射为一个唯一的数组索引。然而，健的数量是无线的，数组的长度是优先的，一个更现实的目标是让散列函数尽量将键均匀的映射到数组中。
即使使用一个高效的散列函数，仍然存在将两个键映射成同一个值的可能，这个现象称为碰撞。
每当碰撞发生时，需要有方案可以解决。
要确定的最后一个问题是：散列表中的数组究竟应该有多大？这是编写 散列函数时必须要考虑的。对数组大小常见的限制是：数组长度应该是一个质数。
##### 下图展示了一个电话簿：  
| 姓名 | 散列函数(姓名字母ASCII码之和) | 散列值 |  
| :----- | :---- | :---- |  
| Durr | 68+117+114+114 | 413 |  
| Smith | 83+109+105+116+104 | 517 |  
| Jones| 74+111+110+101+115 |511 |  
该电话簿对应的散列表为：  
|序号|姓名|  
|------|------  
|0||  
|...||  
|413|Durr|  
|...||  
|511|Jones|  
|...||  
|517|Smith|  
|||
## 二 创建HashTable类
#### 2.1 基础的哈希表
创建一个散列类HashTable，该类包含计算散列值的方法，向散列标中插入数据的方法，从散列表中获取数据的方法，显示散列表中数据分布的方法，以及一些辅助方法。
注意：  
散列函数的选择依赖于健的数据类型。如果健是整型，最简单的散列函数就是以数组的长度对健取余。在一些情况下，比如数组的长度是10，而健都是10的倍数时，不能使用该方式。这也是数组的长度为什么要是质数的原因之一，就像构造函数中的table数组设置长度为137一样。如果健是随机的整数，则散列函数应该更均匀的分布这些键。这种散列方式称为除留余数法。  
在很多应用中，键是字符串类型。这时候要考虑很多因素。乍一看，将字符串中每个字符的ASCII码值相加似乎是一个不错的散列函数，这样散列值就是ASCII码的和除以数组的长度的余数，如下所示：
```js
function HashTable() {
    this.table = new Array(137);
}
HashTable.prototype = {
    constructor: HashTable,
    hashSimple(data) {
        var total = 0;
        for( var i = 0; i < data.length; i++ ) {
            total += data.charCodeAt(i);
        }
        return total % this.table.length;
    },
    put(data) {
        var pos = this.hashSimple(data);
        this.table[pos] = data;
    },
    get() {
        
    },
    showDistro() {
        for(var i = 0; i < this.size(); i++) {
            if(this.table[i]) {
                console.log(i + ": " + this.table[i]);
            }
        }   
    },
    size() {
        return this.table.length;
    }
}
```
测试代码：
```js
var hashT = new HashTable();
hashT.put("zs");
hashT.put("ls");
hashT.put("Raymond");
hashT.put("Clayton");
hashT.showDistro(); // 输出 45:Clayton 86: ls   100: zs  (少了 Raymond)
```
#### 2.2 更好的散列函数
输出少一个的原因：Raymond与Clayton的散列值是一样的。这就是碰撞。  
为了避免碰撞，首先要确保散列表中用来存储数据的数组大小是质数，这和计算散列值时使用取余运算有关。  
数组的长度应该在100以上，这是为了让数据在散列表中分布的更均匀。  
通过实验发现：比100大且不会让案例中数据产生碰撞的第一个质数是137，使用其他更接近100的质数，在该数据集上依然会产生碰撞。  
为了避免碰撞，在给散列表一个合适的大小后，可以使用霍纳算法解决问题。  
霍纳算法；
```
散列函数依然先计算字符串中各个字符串的ASCII码值，不过求和时每次要乘以一个质数；
大多算法书建议使用较小质数31，我们的案例中31不起作用，我们使用37
```
更好的散列函数：
```js

```

