## 一 散列介绍
#### 1.1 散列表
散列是非常常用的数据存储技术，散列后的数据可以快速的插入或者取用，散列使用的数据结构叫做散列表。但是相应的，查找的效率变得很低，比如找出数据中的最大和最小值。
本节案例的散列表根据数组开发，所有元素根据和该元素对应的健，保存在数组的特定位置。使用散列表存储数据时，通过一个散列函数将健映射为一个数字，这个数字的范围是0到散列表的长度。
#### 1.2 碰撞
理想情况下，散列函数会将每个健值映射为一个唯一的数组索引。然而，健的数量是无线的，数组的长度是优先的，一个更现实的目标是让散列函数尽量将键均匀的映射到数组中。
即使使用一个高效的散列函数，仍然存在将两个键映射成同一个值的可能，这个现象称为碰撞。
每当碰撞发生时，需要有方案可以解决。
要确定的最后一个问题是：散列表中的数组究竟应该有多大？这是编写 散列函数时必须要考虑的。对数组大小常见的限制是：数组长度应该是一个质数。
下图展示了一个电话簿：
|姓名|散列函数（姓名字母ASCII码之和）|散列值|
|-|-|-|
|Durr|68+117+114+114|413
|Smith|83+109+105+116+104|517
|Jones|74+111+110+101+115|511
该电话簿对应的散列表为：
|序号|姓名|
|-|-|
|0||
|...||
|413|Durr|
|...||
|511|Jones|
|...||
|517|Smith|
|||
## 创建HashTable类
创建一个散列类HashTable，该类包含计算散列值的方法，向散列标中插入数据的方法，从散列表中获取数据的方法，显示散列表中数据分布的方法，以及一些辅助方法。
注意：  
散列函数的选择依赖于健的数据类型。如果健是整型，最简单的散列函数就是以数组的长度对健取余。在一些情况下，比如数组的长度是10，而健都是10的倍数时，不能使用该方式。这也是数组的长度为什么要是质数的原因之一，就像构造函数中的table数组设置长度为137一样。如果健是随机的整数，则散列函数应该更均匀的分布这些键。这种散列方式称为除留余数法。  
在很多应用中，键是字符串类型。这时候要考虑很多因素。乍一看，将字符串中每个字符的ASCII码值相加似乎是一个不错的散列函数，这样散列值就是ASCII码的和除以数组的长度的余数，如下所示：
```js
function HashTable() {
    this.table = new Array(137);
}
HashTable.prototype = {
    constructor: HashTable,
    simpleHash() {

    },
    showDistro() {

    },
    put() {

    },
    get() {
        
    }
}
```
