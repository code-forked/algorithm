## 一 栈简介  

#### 1.1 栈的引入

其实数组和链表都是非常基础的数据结构，常见的栈、队列等都可以使用这些基础结构实现。  

栈是一种后进先出（LIFO）的有序集合。新添加的或者待删除的元素都保存在栈顶，在栈里，新元素靠近栈顶，旧元素都接近栈低。那么这也造成了任何不在栈顶的元素都无法访问，为了得到栈低的元素，必须先拿掉上面的元素。  

栈经常被编程语言用来存储变量、方法的调用。    

生活中的举例：手枪中的子弹夹，铺起来的书（后来的书总是放在最上面，要拿走也是拿走最上面的书籍）。
![](/images/Algorithm/04-stack1.jpeg)  

开发中的举例：方法的顺序调用，浏览器中的历史记录回退

#### 1.2 栈的使用说明

根据生活中的使用方式对应，栈(stack)是只允许表尾插入和删除的线性表。我们把允许插入和删除ed一端叫做栈顶(top)，另一端称为栈底(bottom)。  

栈是个线性表，因为栈中的元素具有线性关系，即前驱和后继关系，不过栈比较特殊，只能进行栈顶的插入和删除。  

栈的插入操作，常称为压栈或者入栈。栈的删除操作常称为出栈或者弹栈。  

## 二 栈的Go实现  

#### 2.1 顺序结构栈

既然栈是线性表的特例，那么栈的书序存储其实也是线性表顺序存储的简化，简称为顺序栈。线性表是用数组来实现的(Go中使用Slice)。  

数组的下标为0的元素可以代表栈底，因为首元素都存在栈底。

#### 2.2 Go版本实现

```go
/**
 * 栈:顺序结构
 */

package stack

type SeqStack struct {
	Data   []interface{} // 线性表内数据
	Length int
}

func NewSeqStack() *SeqStack {
	s := make([]interface{}, 0)
	return &SeqStack{
		s,
		0,
	}
}

// 压栈
func (ss *SeqStack) Push(data interface{}) {
	ss.Data = append(ss.Data, data)
	ss.Length++
}

// 出栈
func (ss *SeqStack) Pop() interface{} {
	if ss.Length == 0 {
		panic("当前栈是空栈")
	}
	index := ss.Length - 1
	value := ss.Data[index]
	ss.Data = append(ss.Data[:index])
	ss.Length--
	return value
}

// 清空栈
func (ss *SeqStack) Clear() {
	ss = NewSeqStack()
}

```

## 三 栈的JS实现

#### 3.1 HS的栈对象

在JS中模拟一个栈的对象如下：
```JavaScript
function Stack() {
    this.store = [];        //栈内部使用一个数据结构来保存栈里的元素，这里使用数组：
}
```
以上只是建立了栈的一个“壳”，我们需要实现栈对应的增删改查，且需要对应栈先进后出的特征。  

#### 3.2  JS实现栈的增删改查
```JavaScript
//增:直接使用数组的push方法保存
Stack.prototype.push = function(e) {
    this.store.push(e);

}
//删:只能删除栈顶元素，即最后加入数组中的元素 pop方法正合适
Stack.prototype.pop = function() {
    return this.store.pop();
}

/* 通过上述的增删，已经实现了Stack对象的 LIFO原则 */

//获取栈长度
Stack.prototype.size = function() {
    return this.store.length;
}
//获取栈顶元素
Stack.prototype.peek = function() {
    return this.store[this.store.length - 1]
}
//清空栈
Stack.prototype.clear = function() {
    arr.splice(0, arr.length);
}
```
使用：
```JavaScript
var stack = new Stack();
stack.push(1)
stack.push(2)
stack.push(3)
stack.pop()
```
执行过程：
![](/images/Algorithm/04-stack2.png)

#### 3.3 ES6模拟栈
ES6提供了class类仿造Java中的类，但是却不具备私有属性的功能，用class声明一个Stack类，内部的items数组是可以被外界访问到的，我们需要制造一种私有化items的方案。
利用Symbol可以实现：
```JavaScript
let _store = Symbol();
class Statck {
    constructor(){
        this[_store] = [];
    }
    //各种方法
}
```
但是ES6同样也新增了Object.getOwnPropertySymbols方法获取类里面声明的所有Symbol属性。
最终方式：使用WeakMap，同时使用闭包方式将class外部声明的WeakMap实例包裹，防止别人随意改动该实例。
```JavaScript
let Stack = (function () {
    const store = new WeakMap();
    class Stack {
        constructor(){
            store.set(this, [])
        }
        push(e){
            store.get(this).push(e);
        }
        pop(){
            return store.get(this).pop();
        }
        size(){
            return store.get(this).length;
        }
        //其他方法
    }
    return Stack;
})();
```
