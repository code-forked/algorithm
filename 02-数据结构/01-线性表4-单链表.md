## 二 单链表Go实现

#### 2.1 单链表结构
```
单链表对象  LinkedList
线性表数据  Node{数据, next}          # next是下一个元素的指针
线性表方法    
           NewLinkedList()          # 初始化一个线性表
           IsEmpty()            	# 判断线性表是否为空
           Push()               	# 在list末尾插入元素
           GetByIndex()  			# 根据位置获取单链表某个元素
           GetByValue()  			# 根据值获获取单链表某个元素
```

#### 2.2 单链表实现

```go
/**
 * 单链表
 */

package list

import "errors"

// 先设计一个结点对象，存储单链表上某个结点数据
type node struct {
	Data interface{}			// 数据域
	Next *node					// 指针域
}

// 再设计单链表对象
type LinkedList struct {
	Head *node					// 单链表头，有了头结点，就能找到所有结点
	Length int					// 当前链表中数据元素数量
}

// 创建单链表
func NewLinkedList() *LinkedList {
	head := &node{0, nil}
	return &LinkedList{
		head,
		0,
	}
}

// 判断空
func (ll *LinkedList)IsEmpty() bool {
	return ll.Head.Next == nil
}

// 增加：从尾部增加一个结点
func (ll *LinkedList) Push(o interface{}){
	appendNode := &node{o, nil}			// 要插入的结点
	lastNode := ll.Head.Next						// 查找最后一个结点
	if lastNode == nil {							// 第一次添加
		ll.Head.Next = appendNode
		ll.Length ++
		return
	}
	for lastNode.Next != nil {						// 不是第一次添加
		lastNode = lastNode.Next
	}

	lastNode.Next = appendNode
	ll.Length ++
}

// 增加：任意位置插入结点
func (ll *LinkedList) Insert(index int, o interface{}) (bool, error){
	if index < 0 || index > ll.Length {
		return false, errors.New("无效的插入位置")
	}
	currentNode := ll.Head
	for i := 0; i < index; i++ {
		currentNode = currentNode.Next		// 找到要插入的位置
	}
	appendNode := &node{Data:o, Next:nil}
	appendNode.Next = currentNode.Next
	currentNode.Next = appendNode
	ll.Length ++
	return true, nil

}

// 删除：删除指定位置结点
func (ll *LinkedList) Delete(index int) (bool, error) {
	if index < 0 || index >= ll.Length {
		return false, errors.New("指定索引位置有误")
	}
	currentNode := ll.Head
	var beforeNode *node
	for i := 0; i <= index; i++ {
		beforeNode, currentNode = currentNode,  currentNode.Next
	}
	beforeNode.Next = currentNode.Next
	currentNode = nil
	ll.Length --
	return true, nil
}

// 查询： 获取指定位置结点
func (ll *LinkedList) GetByIndex(index int) (*node, error) {
	if index < 0 || index >= ll.Length {
		return nil, errors.New("索引越界")
	}
	currentNode := ll.Head
	for i := 0; i <= index; i++ {
		currentNode = currentNode.Next
	}
	return currentNode, nil
}

// 清空链表
func (ll *LinkedList) Clear() {
	currentNode := ll.Head.Next
	for currentNode != nil {
		temp := currentNode.Next
		currentNode = nil
		currentNode = temp
	}
	ll.Head.Next = nil
}
```

测试：
```go
package main

import (
	"algorithm/list"
	"fmt"
)

func main() {

	ll := list.NewLinkedList()
	ll.Push(11)
	fmt.Println(ll.Head.Next.Data)
	fmt.Println(ll.Length)

	ll.Push(22)
	fmt.Println(ll.Head.Next.Next.Data)
	fmt.Println(ll.Length)

	fmt.Println(ll.Insert(2, 66))
	fmt.Println(ll.Head.Next.Next.Data)
	fmt.Println(ll.Length)

	fmt.Println(ll.GetByIndex(2))
}
```

## 三 理解单链表  

单链表的插入图示：  
![](../images/Algorithm/linkedline-7.png)

单链表的插入无需惊动其他结点，只需要让s->next和p->next的指针做一点改变即可。  

同样，删除也是一样的道理。  

如果我们不知道第i个结点的位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构相比没有太大优势。  

但是一旦知道精确的位置，无论插入多少个元素，找到第i位置的指针复杂度为O(n)，但是插入只是简单的移动指针，时间复杂度都是O(1)，而顺序结构线性表，每次移动都是O(n)，所以，对于插入或者删除数据越频繁的操作，单链表的效率优势越明显。

